All of my data is from IGDB API (https://www.igdb.com/api). Generally, I fetched the data of the games, platforms, genres, and themes from the API.
For the games' data, I used the IGDB wrapper (https://github.com/twitchtv/igdb-api-python) to deal with complicated filter consitions. The accessed url is https://api.igdb.com/v4/games. As a result, I extarcted the name, platforms, involved_companies, genres, themes, keywords of the games, sorted by their total game rating and restrcict the games to have at least 10 ratings and must be main games (not dlc, expansion, etc.). Besides, since IGDB API limits the maximum records from one API call to 500, I used offset to get the data of the next 4500 games. The data is saved as a json file called top_5000_games, where each game represents a dictionary with its id, name, platforms, involved_companies, genres, themes, keywords. Platforms store the hardware used to run the game or game delivery network. Genres and themes represent the types of the games. And keywords are words or phrases that get tagged to a game.
As for the platforms, genres, and themes. The purpose to fetch those data is to provide detailed information for the user, since their information is saved as id numbers when fetching from the games endpoint. The accessed urls are https://api.igdb.com/v4/platforms, https://api.igdb.com/v4/genres, https://api.igdb.com/v4/themes.  I simply used requests library to fetch these data, with thie ids and names. All three endpoints have no more than 500 records, so it was easy to complete by one request. The data is also stored as json files.
I exported those files as CSV files to avoid the serialization issues in json files, and the CSV files serve as a form of data caching, where data once fetched and processed is stored for quicker access in future program executions. When reading the file locally, the program will convert each file to json format.
The created network is exported as a json file with the games' ids and connection points. It can be recovered to the network object by running the load_network() function, which is much faster than creating the new network every time.
